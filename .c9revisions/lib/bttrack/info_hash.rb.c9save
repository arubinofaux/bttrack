{"ts":1368130505275,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\nrequire 'fileutils'\n\nmodule Bttrack\n\n  class InfoHash\n\n    attr_reader :id\n\n    def initialize(params)\n      @params = params\n      validate\n    end\n\n    def validate\n      raise 'info_hash is missing' if @params[:info_hash].nil?\n\n      @id = Array(@params[:info_hash].unpack('H*'))[0].to_s\n\n      raise 'invalid info_hash' unless\n        @id =~ /[\\w\\d]{40}/\n    end\n\n    def peers(args)\n      {\n        'interval' => CONF[:announce_interval],\n        'min interval' => CONF[:min_interval],\n        'peers' => args[:compact] ?\n          peers_compact(args[:numwant]) : peers_dictionary(args)\n      }\n    end\n\n    # args: peer (peer_id, ip, port), downloaded, uploaded, left\n    def event(args)\n      peer = args[:peer]\n\n      case args[:event]\n      when 'stopped'\n        delete_peer(peer.id)\n      else\n        File.open(\"#{path}/#{peer.id}\", 'wb') {|f|\n          f.write(Marshal.dump({\n            'downloaded' => args[:downloaded],\n            'uploaded'   => args[:uploaded],\n            'left'       => args[:left],\n            'ip'         => peer.ip,\n            'port'       => peer.port\n          }))\n        }\n      end\n\n      cleanup\n    end\n\n    # info_hash home dir\n    def path\n      path = \"#{CONF[:db_dir]}/#{id[0..1]}/#{id[2..3]}/#{id}\"\n      `mkdir -p #{path}` unless File.directory?(path)\n      path\n    end\n\n    def peers_list_all\n      Dir.chdir(path)\n      Dir.glob('[a-z0-9]*').shuffle\n    end\n\n    # num - number of entries to return\n    def peers_list(num)\n      peers_list_all[0..num].map do |peer_id|\n        hash = Marshal.load(File.open(peer_id, 'rb').read)\n        hash['peer_id'] = peer_id\n        hash\n      end\n    end\n\n    # num - number of entries requested\n    def peers_compact(num)\n      peers_list(num).map do |hash|\n        [hash['ip'].to_i, hash['port'].to_i].pack('Nn')\n      end.join\n    end\n\n    # :numwant - number of peers requested\n    # :no_peer_id - don't include peer_id in response\n    def peers_dictionary(args)\n      peers_list(args[:numwant]).map do |h|\n        d = {'ip' => h['ip'].to_i, 'port' => h['port'].to_i}\n        d['peer_id'] = [h['peer_id']].pack('H*') unless args[:no_peer_id]\n        d\n      end\n    end\n\n    def delete_peer(id)\n      File.delete(id)\n    rescue Errno::ENOENT\n    end\n\n    def cleanup\n\n      Dir.chdir(path)\n\n      # cleanup every 60 seconds?\n      return if File.exists?('.cleanup') &&\n        Time.now - File.stat('.cleanup').mtime < CONF[:cleanup_interval]\n\n      FileUtils.touch('.cleanup')\n\n      Dir.glob('[a-z0-9]*').map do |peer_id|\n        delete_peer(peer_id) unless\n          Time.now - File.stat(peer_id).mtime < CONF[:announce_interval]*2\n      end\n\n    end\n\n    def scrape\n\n      # compile new .scrape file\n      if !File.exists?('.scrape') ||\n        Time.now - File.stat('.scrape').mtime > CONF[:scrape_interval]\n\n        # calculate\n        scrape = peers_list_all.inject({\n          'info_hash' => [id].pack('H*'),\n          'downloaded' => 0,\n          'complete' => 0,\n          'incomplete' => 0\n        }) do |scrape,peer_id|\n          hash = Marshal.load(File.open(peer_id, 'rb').read)\n\n          if hash['left'] == 0\n            scrape['complete'] += 1\n          else\n            scrape['incomplete'] += 1\n          end\n\n          scrape\n        end\n\n        File.open(\"#{path}/.scrape\", 'wb') {|f|  f.write(Marshal.dump(scrape)) }\n\n      else\n        scrape = Marshal.load(File.open(\"#{path}/.scrape\", 'rb').read)\n      end\n\n      scrape\n    end\n\n    # scrape for all torrents\n    def self.scrape\n      Dir.glob(\"#{CONF[:db_dir]}/**/.scrape\").map do |f|\n        Marshal.load(File.open(f).read)\n      end\n    end\n  end\n\nend\n"]],"start1":0,"start2":0,"length1":0,"length2":3633}]],"length":3633}
